import {
  Dictionary,
  List,
  Item,
  BareItem,
  Parameters,
  InnerList,
  ByteSequence
} from './types';

import { Token } from './token';

import { isAscii } from './util';

export function parseDictionary(input: string): Dictionary {

  const parser = new Parser(input);
  return parser.parseDictionary();

}

export function parseList(input: string): List {

  const parser = new Parser(input);
  return parser.parseList();

}

export function parseItem(input: string): Item {

  const parser = new Parser(input);
  return parser.parseItem();

}

export class ParseError extends Error {

  constructor(position: number, message:string) {

    super(`Parse error: ${message} at offset ${position}`);

  }

}

export default class Parser {

  input: string;
  pos: number;

  constructor(input: string) {
    this.input = input;
    this.pos = 0;
  }

  parseDictionary(): Dictionary {

    this.skipWS();
    const dictionary = new Map();
    while(!this.eof()) {

      const thisKey = this.parseKey();
      let member;
      if (this.lookChar()==='=') {
        this.pos++;
        member = this.parseItemOrInnerList();
      } else {
        member = [true, this.parseParameters()];
      }
      dictionary.set(thisKey, member);
      this.skipOWS();
      if (this.eof()) {
        return dictionary;
      }
      this.expectChar(',');
      this.pos++;
      this.skipOWS();
      if (this.eof()) {
        throw new ParseError(this.pos, 'Dictionary contained a trailing comma');
      }
    }
    return dictionary;

  }

  parseList(): List {

    this.skipWS();
    const members: List = [];
    while(!this.eof()) {
      members.push(
        this.parseItemOrInnerList()
      );
      this.skipOWS();
      if (this.eof()) {
        return members;
      }
      this.expectChar(',');
      this.pos++;
      this.skipOWS();
      if (this.eof()) {
        throw new ParseError(this.pos, 'A list may not end with a trailing comma');
      }
    }

    return members;

  }

  parseItem(standaloneItem: boolean = true): Item {

    if (standaloneItem) this.skipWS();

    const result: Item = [
      this.parseBareItem(),
      this.parseParameters()
    ];

    if (standaloneItem) this.checkTrail();
    return result;

  }

  private parseItemOrInnerList(): Item|InnerList {

    if (this.lookChar()==='(') {
      return this.parseInnerList();
    } else {
      return this.parseItem(false);
    }

  }

  private parseInnerList(): InnerList {

    this.expectChar('(');
    this.pos++;

    const innerList: Item[] = [];

    while(!this.eof()) {
      this.skipWS();
      if (this.lookChar() === ')') {
        this.pos++;
        return [
          innerList,
          this.parseParameters()
        ];
      }

      innerList.push(this.parseItem(false));

      const nextChar = this.lookChar();
      if (nextChar!==' ' && nextChar !== ')') {
        throw new ParseError(this.pos, 'Expected a whitespace or ) after every item in an inner list');
      }
    }


    throw new ParseError(this.pos, 'Could not find end of inner list');

  }

  private parseBareItem(): BareItem {

    const char = this.lookChar();
    if (char.match(/^[-0-9]/)) {
      return this.parseIntegerOrDecimal();
    }
    if (char === '"') {
      return this.parseString();
    }
    if (char.match(/^[A-Za-z*]/)) {
      return this.parseToken();
    }
    if (char === ':' ) {
      return this.parseByteSequence();
    }
    if (char === '?') {
      return this.parseBoolean();
    }

    throw new ParseError(this.pos, 'Unexpected input');

  }

  private parseParameters(): Parameters {

    const parameters = new Map();
    while(!this.eof()) {
      const char = this.lookChar();
      if (char!==';') {
        break;
      }
      this.pos++;
      this.skipWS();
      const key = this.parseKey();
      let value: BareItem = true;
      if (this.lookChar() === '=') {
        this.pos++;
        value = this.parseBareItem();
      }
      parameters.set(key, value);
    }

    return parameters;

  }

  private parseIntegerOrDecimal(): number {

    let type: 'integer' | 'decimal' = 'integer';
    let sign = 1;
    let inputNumber = '';
    if (this.lookChar()==='-') {
      sign = -1;
      this.pos++;
    }

    // The spec wants this check but it's unreachable code.
    //if (this.eof()) {
    //  throw new ParseError(this.pos, 'Empty integer');
    //}

    if (!isDigit(this.lookChar())) {
      throw new ParseError(this.pos, 'Expected a digit (0-9)');
    }

    while(!this.eof()) {
      const char = this.getChar();
      if (isDigit(char)) {
        inputNumber+=char;
      } else if (type === 'integer' && char === '.') {
        if (inputNumber.length>12) {
          throw new ParseError(this.pos, 'Exceeded maximum decimal length');
        }
        inputNumber+='.';
        type = 'decimal';
      } else {
        // We need to 'prepend' the character, so it's just a rewind
        this.pos--;
        break;
      }

      if (type === 'integer' && inputNumber.length>15) {
        throw new ParseError(this.pos, 'Exceeded maximum integer length');
      }
     